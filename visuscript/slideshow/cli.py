"""A utility for presenting a slideshow generated with Visuscript."""

from argparse import ArgumentParser
from pathlib import Path
from dataclasses import dataclass
import json
import time

try:
    import cv2
except ModuleNotFoundError:
    print("'opencv-python' is a dependency for this utility but is not installed. You can install it with `pip install opencv-python`.")
    exit(1)



def main():

    parser = ArgumentParser(__doc__)
    parser.add_argument("video_file", type=Path, help="The video file that contains the frames for the slideshow.")
    parser.add_argument("slideshow_data_file", type=Path, help="The file generated by Visuscript that contains the data necessary for running the slideshow.")

    args = parser.parse_args()

    VIDEO_FILE: Path = args.video_file
    SLIDESHOW_DATA_FILE: Path = args.slideshow_data_file
    

    with open(SLIDESHOW_DATA_FILE) as f:
        metadata = json.load(f)
    slide_start_frames: list[int] = list(map(int, metadata['slide_start_frames']))

    FPS: int = metadata['fps']
    FRAME_DELAY = int(1/FPS * 1000) - 1

    cap = cv2.VideoCapture(str(VIDEO_FILE))
    last_frame_id = int(cap.get(cv2.CAP_PROP_FRAME_COUNT)) - 1




    slide_start_frames.append(last_frame_id)


    
    state: ProgramState = JumpingToSlide(target_slide=0)


    while cap.isOpened():
        if isinstance(state, JumpingToSlide):
            cap.set(cv2.CAP_PROP_POS_FRAMES, slide_start_frames[state.target_slide])
            ret, frame = cap.read()
            if not ret:
                raise RuntimeError(f"Could not jump to slide {state.target_slide}")
            cv2.imshow('Presentation', frame)
            state = Resting(slide = state.target_slide)
        elif isinstance(state, Animating):
            if state.last_rendered_frame < slide_start_frames[state.target_slide]:
                ret, frame = cap.read()
                if not ret:
                    raise RuntimeError(f"Could not render frame {state.last_rendered_frame + 1}")
                
                time_ahead = state.frames_animated * FRAME_DELAY - (time.time() - state.start_time)
                if time_ahead > 0:
                    time.sleep(time_ahead)
                cv2.imshow('Presentation', frame)
                state.last_rendered_frame += 1
                match get_pressed_key():
                    case Keys.DOWN_ARROW:
                        state = JumpingToSlide(target_slide=state.target_slide)
                    case Keys.UP_ARROW | Keys.LEFT_ARROW:
                        state = JumpingToSlide(target_slide=state.target_slide-1)
                    case _: ...
            elif state.last_rendered_frame == slide_start_frames[state.target_slide]:
                state = Resting(slide=state.target_slide)
            else:
                raise RuntimeError("Internal Error: last rendered frame cannot be greater than the target frame.")
        elif isinstance(state, Resting): # type: ignore
            match get_pressed_key():
                case Keys.SPACE | Keys.RIGHT_ARROW if state.slide + 1 < len(slide_start_frames):
                    state = Animating(last_rendered_frame=slide_start_frames[state.slide], target_slide=state.slide + 1, start_time=time.time())
                case Keys.DOWN_ARROW if state.slide + 1 < len(slide_start_frames):
                    state = JumpingToSlide(target_slide=state.slide + 1)
                case Keys.UP_ARROW | Keys.LEFT_ARROW if state.slide > 0:
                    state = JumpingToSlide(target_slide=state.slide-1)
                case _: ...



    # Release resources
    cap.release()
    cv2.destroyAllWindows()


class ProgramState: ...

@dataclass
class JumpingToSlide(ProgramState):
    target_slide: int

@dataclass
class Animating(ProgramState):
    last_rendered_frame: int
    target_slide: int
    start_time: float
    frames_animated: int = 0

@dataclass
class Resting(ProgramState):
    slide: int


class Keys:
    SPACE = ord(' ')
    UP_ARROW = 0
    DOWN_ARROW = 1
    LEFT_ARROW = 2
    RIGHT_ARROW = 3


def key_pressed(*keys: str):
    return cv2.waitKey(1) & 0xFF in map(ord, keys)

def get_pressed_key():
    return cv2.waitKey(1) & 0xFF

if __name__ == "__main__":
    main()